# Бирюков Никита. Б05-132. ДЗ 1.
## Fibonacci App

## 1. Обзор

Этот проект демонстрирует комплексное развертывание веб-приложения на Python (с использованием фреймворка Flask) в кластере Kubernetes. Приложение выполняет две основные функции:

1.  **Вычисление чисел Фибоначчи**: Предоставляет API-эндпоинт для расчета n-го числа Фибоначчи.
2.  **Обработка логов**: Реализует эндпоинты для записи пользовательских сообщений в лог-файл и для чтения этого лог-файла.

Проект охватывает создание и настройку различных объектов Kubernetes для обеспечения работы приложения, его масштабируемости, мониторинга логов и выполнения периодических задач:

-   **Контейнеризация**: Сборка Docker-образа приложения.
-   **Конфигурация**: Использование ConfigMap для внешнего управления настройками.
-   **Развертывание приложения**: Использование Deployment для управления репликами приложения.
-   **Сетевое взаимодействие**: Использование Service (ClusterIP) для обеспечения стабильного внутреннего доступа и балансировки нагрузки.
-   **Управление логами**:
    -   Запись логов приложением в файл внутри контейнера.
    -   Использование `hostPath` для выноса логов на узел кластера (с пояснением ограничений).
    -   Развертывание DaemonSet с "log-агентом" для сбора логов с каждого узла.
-   **Периодические задачи**: Использование CronJob для симуляции архивации логов.
-   **Автоматизация**: Предоставление bash-скрипта (`deploy.sh`) для автоматического развертывания всех компонентов.

## 2. Функционал Приложения (`app/app.py`)

Приложение Flask предоставляет следующие REST API эндпоинты:

-   **`GET /`**: Возвращает приветственное сообщение. Текст сообщения настраивается через ConfigMap (`WELCOME_MESSAGE`).
    *Пример:* `curl http://<service-ip-or-forwarded-port>/`
-   **`GET /status`**: Возвращает текущий статус приложения и временную метку.
    *Пример:* `curl http://<service-ip-or-forwarded-port>/status`
    *Ответ:* `{"status": "ok", "timestamp": "..."}`
-   **`POST /log`**: Принимает JSON-запрос с полем `"message"` и записывает его значение в лог-файл (`/app/logs/app.log` внутри контейнера).
    *Пример:* `curl -X POST -H "Content-Type: application/json" -d '{"message": "My custom log entry"}' http://<service-ip-or-forwarded-port>/log`
    *Ответ:* `{"status": "logged"}`
-   **`GET /logs`**: Читает и возвращает полное содержимое лог-файла (`/app/logs/app.log`) как простой текст.
    *Пример:* `curl http://<service-ip-or-forwarded-port>/logs`
-   **`GET /fibonacci/<n>`**: Принимает целое положительное число `n` в URL и возвращает n-ое число Фибоначчи в формате JSON.
    *Пример:* `curl http://<service-ip-or-forwarded-port>/fibonacci/10`
    *Ответ:* `{"n": 10, "fibonacci": 55}`

Приложение использует стандартный модуль `logging` Python для записи логов. Путь к файлу логов (`LOG_FILE_PATH`), уровень логирования (`LOG_LEVEL`), порт приложения (`APP_PORT`) и приветственное сообщение (`WELCOME_MESSAGE`) настраиваются через переменные окружения, которые, в свою очередь, берутся из Kubernetes ConfigMap. Используется `RotatingFileHandler` для ограничения максимального размера лог-файла и количества бэкапов.

## 3. Структура Проекта


.
├── app/ \\
│ ├── app.py # Исходный код Flask-приложения\\
│ └── requirements.txt # Зависимости Python (Flask)\\
├── kubernetes/ # YAML-манифесты для Kubernetes\\
│ ├── configmap.yaml # Конфигурация приложения\\
│ ├── deployment.yaml # Развертывание основного приложения\\
│ ├── service.yaml # Сервис для доступа к приложению\\
│ ├── daemonset.yaml # DaemonSet для log-агента\\
│ └── cronjob.yaml # CronJob для архивации логов\\
├── Dockerfile # Инструкции для сборки Docker-образа приложения\\
├── deploy.sh # Bash-скрипт для автоматического развертывания\\
└── README.md # Этот файл\\

## 4. Предварительные Требования

Перед началом работы убедитесь, что у вас установлены и настроены следующие инструменты:

1.  **Docker**: Для сборки образа приложения. [Установка Docker](https://docs.docker.com/engine/install/)
2.  **kubectl**: Утилита командной строки для взаимодействия с Kubernetes. [Установка kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/)
3.  **Kubernetes Кластер**: Локальный (Minikube, Kind, Docker Desktop Kubernetes) или облачный (GKE, EKS, AKS). Убедитесь, что `kubectl` настроен на работу с вашим кластером (`kubectl config current-context`).
4.  **(Опционально) Docker Hub Аккаунт или доступ к другому Реестру Контейнеров**: Если вы планируете использовать образ не только в локальном кластере, вам потребуется место для его хранения.

## 5. Порядок Запуска Проекта

Следуйте этим шагам для развертывания приложения и всех связанных компонентов:

**Шаг 1: Сборка Docker-образа**

1.  Перейдите в корневую директорию проекта.
2.  Выполните команду сборки Docker-образа. **Важно:** Замените `<your-dockerhub-username>` на ваш реальный логин в Docker Hub или на полный адрес вашего приватного/корпоративного реестра.
    ```bash
    docker build -t <your-dockerhub-username>/fibonacci-app:latest .
    ```
    *Пример:* `docker build -t johndoe/fibonacci-app:latest .`

3.  **(Опционально) Публикация образа в реестр:** Если ваш Kubernetes-кластер не имеет прямого доступа к локальным образам Docker (например, это облачный кластер), вам нужно опубликовать (push) собранный образ в реестр:
    ```bash
    # Войдите в ваш реестр (если требуется)
    # docker login [your-registry.com]
    docker push <your-dockerhub-username>/fibonacci-app:latest
    ```
    *Примечание для локальных кластеров:* Если вы используете Minikube, вы можете собрать образ прямо в Docker-окружении Minikube, чтобы избежать необходимости push'а:
    ```bash
    eval $(minikube docker-env)
    docker build -t <your-dockerhub-username>/fibonacci-app:latest .
    # После этого не нужно делать push, кластер увидит образ локально.
    # Вернуться в обычное Docker-окружение: eval $(minikube docker-env -u)
    ```

**Шаг 2: Настройка и Запуск Скрипта Развертывания**

1.  **Убедитесь, что `kubectl` настроен на ваш целевой Kubernetes кластер.** Проверьте текущий контекст:
    ```bash
    kubectl config current-context
    ```

2.  **Отредактируйте скрипт `deploy.sh`**: Откройте файл `deploy.sh` в текстовом редакторе и **обязательно** измените значение переменной `DOCKER_IMAGE_NAME` на то имя образа, которое вы использовали при сборке на Шаге 1.
    ```bash
    # В файле deploy.sh найдите и измените эту строку:
    DOCKER_IMAGE_NAME="${DOCKER_USERNAME:-your-dockerhub-username}/fibonacci-app:latest"
    # Замените your-dockerhub-username/fibonacci-app:latest на ваше имя образа, например:
    # DOCKER_IMAGE_NAME="johndoe/fibonacci-app:latest"
    # Или установите переменную окружения DOCKER_USERNAME перед запуском:
    # export DOCKER_USERNAME="johndoe"
    # ./deploy.sh
    ```

3.  **Предоставьте скрипту права на выполнение:**
    ```bash
    chmod +x deploy.sh
    ```

4.  **Запустите скрипт развертывания:**
    ```bash
    ./deploy.sh
    ```

**Что делает скрипт `deploy.sh`:**

-   Применяет `configmap.yaml` для создания ConfigMap.
-   Генерирует временный `deployment.yaml` с вашим именем Docker-образа (подставляя значение `DOCKER_IMAGE_NAME`).
-   Применяет этот временный `deployment.yaml` для создания Deployment'а.
-   Применяет `service.yaml` для создания Service.
-   Применяет `daemonset.yaml` для создания DaemonSet (log-агент).
-   Применяет `cronjob.yaml` для создания CronJob (архиватор логов).
-   Ожидает, пока Deployment и DaemonSet перейдут в готовое состояние (`rollout status`, `kubectl wait`).
-   Выводит инструкции по доступу к приложению и проверке других компонентов.

**Шаг 3: Доступ к Приложению и Проверка**

После успешного выполнения скрипта `deploy.sh`, вы можете получить доступ к приложению. Поскольку мы создали Service типа `ClusterIP`, он доступен только внутри кластера. Самый простой способ получить доступ с локальной машины — использовать `kubectl port-forward`:

1.  Откройте **новый терминал** и выполните команду, предложенную скриптом:
    ```bash
    kubectl port-forward service/fibonacci-service 9090:80
    ```
    Эта команда пробросит порт `80` сервиса `fibonacci-service` на порт `9090` вашей локальной машины. Оставьте этот терминал открытым.

2.  В **другом терминале** вы можете теперь обращаться к приложению через `http://localhost:9090`:

    *   **Проверить приветствие:**
        ```bash
        curl http://localhost:9090/
        ```
    *   **Проверить статус:**
        ```bash
        curl http://localhost:9090/status
        ```
    *   **Вычислить число Фибоначчи (например, 15-е):**
        ```bash
        curl http://localhost:9090/fibonacci/15
        ```
    *   **Отправить сообщение в лог:**
        ```bash
        curl -X POST -H "Content-Type: application/json" -d '{"message": "Testing logs via port-forward"}' http://localhost:9090/log
        ```
    *   **Прочитать логи приложения (из одного из подов):**
        ```bash
        curl http://localhost:9090/logs
        ```
        *Примечание: Этот запрос попадет только в один из подов приложения, поэтому вы увидите лог только этого пода.*

**Шаг 4: Проверка Других Компонентов**

*   **Проверить поды приложения (Deployment):**
    ```bash
    kubectl get pods -l app=fibonacci-app
    ```
    Вы должны увидеть 3 пода со статусом `Running`.

*   **Проверить поды log-агента (DaemonSet):**
    ```bash
    kubectl get pods -l app=log-agent -o wide
    ```
    Вы увидите по одному поду на каждом узле вашего кластера.

*   **Посмотреть логи, собранные log-агентом:** Выберите имя одного из подов log-агента (из вывода предыдущей команды) и посмотрите его логи:
    ```bash
    # Замените <log-agent-pod-name> на реальное имя пода
    kubectl logs <log-agent-pod-name>
    ```
    Вы должны увидеть сообщения, которые вы отправляли через `POST /log`.

*   **Проверить CronJob и его выполненные задачи (Jobs):**
    ```bash
    # Посмотреть статус CronJob
    kubectl get cronjob fibonacci-log-archiver

    # Посмотреть Jobs, созданные CronJob'ом (появляются каждые 10 минут)
    kubectl get jobs -l job-name=fibonacci-log-archiver-*

    # Посмотреть логи конкретного Job'а (выберите имя пода из 'kubectl get pods -l job-name=...')
    kubectl logs <cronjob-pod-name>
    ```

## 6. Подробное Описание Компонентов

### 6.1. Приложение (`app/`)

-   **`app.py`**: Основа приложения. Использует Flask для создания веб-сервера и обработки HTTP-запросов. Реализует эндпоинты, логику Фибоначчи и запись/чтение логов. Конфигурируется через переменные окружения.
-   **`requirements.txt`**: Содержит зависимость `Flask`.

### 6.2. Dockerfile

-   Определяет шаги для создания Docker-образа приложения.
-   Использует базовый образ `python:3.9-slim`.
-   Копирует код приложения и файл зависимостей.
-   Устанавливает зависимости с помощью `pip`.
-   Открывает порт `8080` (порт по умолчанию для приложения).
-   Задает команду для запуска приложения (`CMD ["python", "app.py"]`).

### 6.3. Kubernetes Манифесты (`kubernetes/`)

-   **`configmap.yaml`**:
    -   Определяет ConfigMap `fibonacci-app-config`.
    -   Хранит конфигурационные параметры как пары ключ-значение (`APP_PORT`, `LOG_LEVEL`, `LOG_FILE_PATH`, `WELCOME_MESSAGE`).
    -   Эти значения используются Deployment'ом для установки переменных окружения в контейнерах приложения.
-   **`deployment.yaml`**:
    -   Определяет Deployment `fibonacci-deployment`.
    -   **`replicas: 3`**: Указывает Kubernetes поддерживать 3 работающих экземпляра (пода) приложения для отказоустойчивости и распределения нагрузки.
    -   **`strategy: RollingUpdate`**: Определяет стратегию плавного обновления при изменении шаблона пода (например, при обновлении образа).
    -   **`selector`**: Связывает Deployment с подами, имеющими метку `app: fibonacci-app`.
    -   **`template`**: Описывает под, который будет создаваться Deployment'ом.
        -   **`metadata.labels`**: Устанавливает метку `app: fibonacci-app` для пода.
        -   **`spec.containers`**: Определяет контейнер приложения.
            -   **`image`**: Указывает Docker-образ для запуска (заменяется скриптом `deploy.sh`).
            -   **`ports.containerPort: 8080`**: Информирует Kubernetes, что контейнер слушает порт 8080.
            -   **`envFrom.configMapRef`**: Указывает, что все ключи из ConfigMap `fibonacci-app-config` должны стать переменными окружения для контейнера.
            -   **`volumeMounts`**: Монтирует том `log-volume` в директорию `/app/logs` внутри контейнера.
        -   **`spec.volumes`**: Определяет тома, используемые подом.
            -   **`log-volume`**: Определен как `hostPath`, указывающий на директорию `/var/log/fibonacci-app-logs` на *узле* кластера. **Важно:** Это сделано для того, чтобы DaemonSet (log-агент) мог получить доступ к логам с узла. Однако это имеет **существенный недостаток**: если несколько подов приложения окажутся на одном узле, они будут писать в *один и тот же файл* `/var/log/fibonacci-app-logs/app.log` на узле, что приведет к смешиванию или перезаписи логов. В production-средах обычно используют другие подходы (логирование в stdout/stderr или sidecar-контейнеры).
        -   **`template.metadata.annotations.configmap-version`**: Эта аннотация добавлена как простой механизм для ручного или автоматизированного триггера обновления Deployment'а при изменении ConfigMap. Простое изменение ConfigMap *не* приведет к автоматическому обновлению подов, использующих `envFrom`. Нужно изменить что-то в `template` (например, эту аннотацию или образ) и переприменить Deployment, чтобы Kubernetes начал Rolling Update. Инструменты типа [Reloader](https://github.com/stakater/Reloader) могут автоматизировать этот процесс.
-   **`service.yaml`**:
    -   Определяет Service `fibonacci-service`.
    -   **`type: ClusterIP`**: Делает сервис доступным только по внутреннему IP-адресу кластера.
    -   **`selector`**: Направляет трафик на поды с меткой `app: fibonacci-app` (т.е. на поды, созданные Deployment'ом).
    -   **`ports`**: Определяет порты. Трафик, приходящий на порт `80` сервиса, будет перенаправлен на `targetPort: 8080` (порт контейнера) подходящего пода. Service также выполняет балансировку нагрузки между репликами.
-   **`daemonset.yaml`**:
    -   Определяет DaemonSet `log-agent-daemonset`.
    -   Гарантирует, что по одному экземпляру пода log-агента будет запущено на *каждом* узле кластера.
    -   **`template`**: Описывает под log-агента.
        -   Использует простой образ `busybox`.
        -   Запускает команду `tail -n+1 -F /mnt/host-logs/app.log`, которая непрерывно читает содержимое файла логов приложения (включая его пересоздание) и выводит его в стандартный вывод (stdout) контейнера агента.
        -   **`volumeMounts`**: Монтирует том `host-log-dir` (который является `hostPath` к `/var/log/fibonacci-app-logs`) в `/mnt/host-logs` внутри контейнера агента (в режиме `readOnly`). Это позволяет агенту читать лог-файл, созданный подами приложения на этом узле.
-   **`cronjob.yaml`**:
    -   Определяет CronJob `fibonacci-log-archiver`.
    -   **`schedule: "*/10 * * * *"`**: Запускает задачу каждые 10 минут.
    -   **`jobTemplate`**: Описывает Job, который будет создаваться по расписанию.
        -   **`template`**: Описывает под, выполняющий задачу.
            -   Использует образ `alpine/curl` (или другой с `curl`).
            -   Выполняет команду `curl`, которая обращается к эндпоинту `/logs` сервиса `fibonacci-service` для получения текущих логов (от одного из подов приложения).
            -   Сохраняет полученные логи во временный файл `/tmp/app-logs-dump-<timestamp>.log` внутри пода CronJob.
            -   **(Закомментировано)** Пример команды `tar` для архивации полученного файла. Для ее работы нужен образ, содержащий утилиту `tar` (например, `alpine` с установленным `tar` через `apk add`).
        -   **`restartPolicy: OnFailure`**: Перезапускать под, только если он завершился с ошибкой.
        -   **`ttlSecondsAfterFinished: 300`**: Автоматически удалять завершившиеся поды Job'а через 5 минут для экономии ресурсов.

### 6.4. Скрипт Развертывания (`deploy.sh`)

-   Автоматизирует процесс развертывания.
-   Устанавливает переменную `DOCKER_IMAGE_NAME` (требует редактирования пользователем).
-   Использует `kubectl apply -f` для создания или обновления всех Kubernetes-ресурсов из файлов в директории `kubernetes/`.
-   Использует `sed` для подстановки правильного имени образа в `deployment.yaml` перед его применением.
-   Использует `kubectl rollout status` и `kubectl wait` для ожидания готовности Deployment'а и DaemonSet'а.
-   Выводит полезные команды для проверки и доступа к приложению.

## 7. Важные Замечания и Возможные Проблемы

-   **Использование `hostPath` для логов**: Как уже упоминалось, это решение имеет существенные недостатки в production, особенно риск смешивания логов от разных подов на одном узле. Более надежные подходы включают:
    -   **Логирование в stdout/stderr**: Приложение пишет логи в стандартный вывод/ошибок. Kubernetes и среда выполнения контейнеров (Docker, containerd) перехватывают эти потоки и сохраняют их. Централизованные системы сбора логов (Fluentd, Fluent Bit, Logstash), часто развернутые как DaemonSet, собирают эти логи с узлов.
    -   **Sidecar-контейнер**: Добавление второго контейнера (например, с Fluent Bit) в *каждый* под приложения. Этот sidecar читает лог-файл из общего тома (`emptyDir`) и отправляет его в централизованное хранилище.
-   **Обновление ConfigMap**: Изменения в ConfigMap *не* отражаются автоматически в подах, которые используют `envFrom`. Чтобы поды получили новые значения, необходимо инициировать обновление Deployment'а (например, изменив аннотацию `configmap-version` в `deployment.yaml` и выполнив `kubectl apply -f kubernetes/deployment.yaml`, или используя инструменты типа Reloader).
-   **Зависимость `tar` в CronJob**: Если вы раскомментируете команду `tar` в `cronjob.yaml`, убедитесь, что используемый образ контейнера (например, `alpine/curl`) содержит утилиту `tar`. Возможно, потребуется выбрать другой образ или создать свой.
-   **Замена имени образа**: Не забывайте заменять плейсхолдер `<your-dockerhub-username>/fibonacci-app:latest` на ваше реальное имя образа при сборке и в скрипте `deploy.sh`.

## 8. Очистка Ресурсов

Чтобы удалить все ресурсы, созданные этим проектом, из вашего кластера Kubernetes, выполните следующие команды:

```bash
echo "Удаление CronJob..."
kubectl delete cronjob fibonacci-log-archiver --ignore-not-found=true

echo "Удаление DaemonSet..."
kubectl delete daemonset log-agent-daemonset --ignore-not-found=true

echo "Удаление Service..."
kubectl delete service fibonacci-service --ignore-not-found=true

echo "Удаление Deployment..."
kubectl delete deployment fibonacci-deployment --ignore-not-found=true

echo "Удаление ConfigMap..."
kubectl delete configmap fibonacci-app-config --ignore-not-found=true

# (Опционально) Удалить Jobs, созданные CronJob'ом, если они еще существуют
# kubectl delete jobs -l job-name=fibonacci-log-archiver-* --ignore-not-found=true

echo "Очистка завершена."
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END

Примечание: Если вы использовали hostPath, файлы логов (/var/log/fibonacci-app-logs/app.log) могут остаться на узлах вашего кластера. Их нужно будет удалить вручную при необходимости.

IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END
